"use strict";(globalThis.webpackChunkfrontend=globalThis.webpackChunkfrontend||[]).push([[2205],{7852:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"chapter5","title":"Chapter 5: Motion Planning & Control","description":"Learn how humanoid robots plan, balance, and move safely.","source":"@site/docs/chapter5.md","sourceDirName":".","slug":"/chapter5","permalink":"/Physical-AI-Humanoid-Robotics/docs/chapter5","draft":false,"unlisted":false,"editUrl":"https://github.com/SidraRaza/Physical-AI-Humanoid-Robotics/edit/main/docs/chapter5.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"Chapter 5: Motion Planning & Control","description":"Learn how humanoid robots plan, balance, and move safely.","sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 4: Perception Systems","permalink":"/Physical-AI-Humanoid-Robotics/docs/chapter4"},"next":{"title":"Chapter 6: Learning for Robotics","permalink":"/Physical-AI-Humanoid-Robotics/docs/chapter6"}}');var r=i(4848),t=i(8453);const s={title:"Chapter 5: Motion Planning & Control",description:"Learn how humanoid robots plan, balance, and move safely.",sidebar_position:5},l="Motion Planning & Control",a={},c=[{value:"Introduction to Motion Planning",id:"introduction-to-motion-planning",level:2},{value:"The Motion Planning Problem",id:"the-motion-planning-problem",level:3},{value:"Configuration Space",id:"configuration-space",level:3},{value:"Path Planning Algorithms",id:"path-planning-algorithms",level:2},{value:"Grid-Based Methods",id:"grid-based-methods",level:3},{value:"Sampling-Based Methods",id:"sampling-based-methods",level:3},{value:"Probabilistic Roadmaps (PRM)",id:"probabilistic-roadmaps-prm",level:3},{value:"Trajectory Optimization",id:"trajectory-optimization",level:2},{value:"From Path to Trajectory",id:"from-path-to-trajectory",level:3},{value:"Trajectory Optimization Formulation",id:"trajectory-optimization-formulation",level:3},{value:"Numerical Optimization Methods",id:"numerical-optimization-methods",level:3},{value:"Humanoid Balance Control",id:"humanoid-balance-control",level:2},{value:"The Balance Problem",id:"the-balance-problem",level:3},{value:"Zero Moment Point (ZMP)",id:"zero-moment-point-zmp",level:3},{value:"Linear Inverted Pendulum Model (LIPM)",id:"linear-inverted-pendulum-model-lipm",level:3},{value:"Capture Point Dynamics",id:"capture-point-dynamics",level:3},{value:"Walking Pattern Generation",id:"walking-pattern-generation",level:2},{value:"Footstep Planning",id:"footstep-planning",level:3},{value:"Center of Mass Trajectory",id:"center-of-mass-trajectory",level:3},{value:"Swing Leg Trajectory",id:"swing-leg-trajectory",level:3},{value:"Whole-Body Control",id:"whole-body-control",level:2},{value:"Task-Space Control",id:"task-space-control",level:3},{value:"Hierarchical Task Control",id:"hierarchical-task-control",level:3},{value:"Optimization-Based Control",id:"optimization-based-control",level:3},{value:"Impedance and Compliance Control",id:"impedance-and-compliance-control",level:2},{value:"Impedance Control",id:"impedance-control",level:3},{value:"Variable Impedance",id:"variable-impedance",level:3},{value:"Model Predictive Control (MPC)",id:"model-predictive-control-mpc",level:2},{value:"MPC Framework",id:"mpc-framework",level:3},{value:"MPC for Locomotion",id:"mpc-for-locomotion",level:3},{value:"Safety and Constraint Handling",id:"safety-and-constraint-handling",level:2},{value:"Collision Avoidance",id:"collision-avoidance",level:3},{value:"Safety Constraints in Control",id:"safety-constraints-in-control",level:3},{value:"Summary",id:"summary",level:2},{value:"Review Questions",id:"review-questions",level:2},{value:"Hands-On Exercise",id:"hands-on-exercise",level:2}];function d(n){const e={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"motion-planning--control",children:"Motion Planning & Control"})}),"\n",(0,r.jsx)(e.p,{children:"Motion planning and control are at the heart of Physical AI, determining how robots move through the world safely and efficiently. This chapter covers the algorithms and techniques that enable humanoid robots to plan paths, maintain balance, and execute complex movements."}),"\n",(0,r.jsx)(e.h2,{id:"introduction-to-motion-planning",children:"Introduction to Motion Planning"}),"\n",(0,r.jsx)(e.h3,{id:"the-motion-planning-problem",children:"The Motion Planning Problem"}),"\n",(0,r.jsx)(e.p,{children:"Given:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Start configuration"}),": Current robot state"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Goal configuration"}),": Desired robot state"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Obstacles"}),": Things to avoid"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Constraints"}),": Physical limitations"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"Find:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["A ",(0,r.jsx)(e.strong,{children:"collision-free path"})," from start to goal"]}),"\n",(0,r.jsx)(e.li,{children:"That respects robot constraints"}),"\n",(0,r.jsx)(e.li,{children:"Optimized for some criteria (time, energy, smoothness)"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"configuration-space",children:"Configuration Space"}),"\n",(0,r.jsxs)(e.p,{children:["Motion planning operates in ",(0,r.jsx)(e.strong,{children:"configuration space (C-space)"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502           Configuration Space                    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                  \u2502\n\u2502  Workspace: 3D physical space                   \u2502\n\u2502                                                  \u2502\n\u2502  C-space: Space of all robot configurations     \u2502\n\u2502           Dimension = number of DoF             \u2502\n\u2502                                                  \u2502\n\u2502  C-free: Collision-free configurations          \u2502\n\u2502  C-obs: Configurations in collision             \u2502\n\u2502                                                  \u2502\n\u2502  A 7-DoF arm has a 7-dimensional C-space        \u2502\n\u2502                                                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,r.jsx)(e.h2,{id:"path-planning-algorithms",children:"Path Planning Algorithms"}),"\n",(0,r.jsx)(e.h3,{id:"grid-based-methods",children:"Grid-Based Methods"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsxs)(e.em,{children:[(0,r.jsx)(e.em,{children:"A"})," Algorithm"]}),"*"]}),"\n",(0,r.jsx)(e.p,{children:"Classic graph search with heuristics:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"def astar(start, goal, graph, heuristic):\n    open_set = PriorityQueue()\n    open_set.put((0, start))\n    came_from = {}\n    g_score = {start: 0}\n\n    while not open_set.empty():\n        _, current = open_set.get()\n\n        if current == goal:\n            return reconstruct_path(came_from, current)\n\n        for neighbor in graph.neighbors(current):\n            tentative_g = g_score[current] + graph.cost(current, neighbor)\n\n            if tentative_g < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g\n                f_score = tentative_g + heuristic(neighbor, goal)\n                open_set.put((f_score, neighbor))\n\n    return None  # No path found\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Properties:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Complete: Always finds a path if one exists"}),"\n",(0,r.jsx)(e.li,{children:"Optimal: Finds shortest path with admissible heuristic"}),"\n",(0,r.jsx)(e.li,{children:"Complexity: Exponential in path length"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"sampling-based-methods",children:"Sampling-Based Methods"}),"\n",(0,r.jsx)(e.p,{children:"For high-dimensional spaces, sampling methods are practical:"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Rapidly-exploring Random Trees (RRT)"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"Algorithm RRT:\n1. Initialize tree T with start configuration\n2. While goal not reached:\n   a. Sample random configuration q_rand\n   b. Find nearest node q_near in T\n   c. Extend from q_near toward q_rand to get q_new\n   d. If path q_near \u2192 q_new is collision-free:\n      Add q_new to T with edge from q_near\n3. Return path from start to goal\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"RRT Properties:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Probabilistically complete"}),"\n",(0,r.jsx)(e.li,{children:"Explores space efficiently"}),"\n",(0,r.jsx)(e.li,{children:"May produce suboptimal paths"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsxs)(e.em,{children:[(0,r.jsx)(e.em,{children:"RRT"})," (Optimal RRT)"]}),"*"]}),"\n",(0,r.jsx)(e.p,{children:"Improves path quality through rewiring:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"def rrt_star(start, goal, space, max_iterations):\n    tree = Tree()\n    tree.add_node(start, parent=None, cost=0)\n\n    for i in range(max_iterations):\n        # Sample random point\n        q_rand = space.sample()\n\n        # Find nearest node\n        q_near = tree.nearest(q_rand)\n\n        # Steer toward random point\n        q_new = steer(q_near, q_rand)\n\n        if space.collision_free(q_near, q_new):\n            # Find nearby nodes for rewiring\n            near_nodes = tree.near(q_new, radius)\n\n            # Choose best parent\n            q_min = q_near\n            c_min = tree.cost(q_near) + distance(q_near, q_new)\n\n            for q_near_i in near_nodes:\n                c_new = tree.cost(q_near_i) + distance(q_near_i, q_new)\n                if c_new < c_min and space.collision_free(q_near_i, q_new):\n                    q_min = q_near_i\n                    c_min = c_new\n\n            # Add new node\n            tree.add_node(q_new, parent=q_min, cost=c_min)\n\n            # Rewire nearby nodes\n            for q_near_i in near_nodes:\n                c_new = c_min + distance(q_new, q_near_i)\n                if c_new < tree.cost(q_near_i):\n                    if space.collision_free(q_new, q_near_i):\n                        tree.rewire(q_near_i, parent=q_new, cost=c_new)\n\n    return tree.path_to_goal(goal)\n"})}),"\n",(0,r.jsx)(e.h3,{id:"probabilistic-roadmaps-prm",children:"Probabilistic Roadmaps (PRM)"}),"\n",(0,r.jsx)(e.p,{children:"Two-phase approach:"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Phase 1: Roadmap Construction"})}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"Sample n random configurations"}),"\n",(0,r.jsx)(e.li,{children:"Connect nearby configurations with collision-free edges"}),"\n",(0,r.jsx)(e.li,{children:"Result: Graph representing free space"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Phase 2: Query"})}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"Connect start and goal to roadmap"}),"\n",(0,r.jsx)(e.li,{children:"Search for path in roadmap graph"}),"\n",(0,r.jsx)(e.li,{children:"Return path if found"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Best for:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Multiple queries in same environment"}),"\n",(0,r.jsx)(e.li,{children:"Complex, cluttered spaces"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"trajectory-optimization",children:"Trajectory Optimization"}),"\n",(0,r.jsx)(e.h3,{id:"from-path-to-trajectory",children:"From Path to Trajectory"}),"\n",(0,r.jsxs)(e.p,{children:["A ",(0,r.jsx)(e.strong,{children:"path"})," is purely geometric; a ",(0,r.jsx)(e.strong,{children:"trajectory"})," includes timing:"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Path: q(s), s \u2208 [0, 1]"}),"\n",(0,r.jsx)(e.li,{children:"Trajectory: q(t), t \u2208 [0, T]"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"trajectory-optimization-formulation",children:"Trajectory Optimization Formulation"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"minimize    \u222b L(q(t), q\u0307(t), q\u0308(t)) dt\n   q(t)\n\nsubject to  q(0) = q_start\n            q(T) = q_goal\n            q\u0307(t) \u2208 velocity limits\n            q\u0308(t) \u2208 acceleration limits\n            collision_free(q(t)) \u2200t\n"})}),"\n",(0,r.jsx)(e.p,{children:"Common cost functions:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Minimum time"}),": L = 1"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Minimum energy"}),": L = \u03c4\u1d40\u03c4 (torques squared)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Minimum jerk"}),": L = q\u20db\u1d40q\u20db (third derivative)"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"numerical-optimization-methods",children:"Numerical Optimization Methods"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Direct Transcription"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Discretize trajectory into waypoints"}),"\n",(0,r.jsx)(e.li,{children:"Convert to nonlinear program (NLP)"}),"\n",(0,r.jsx)(e.li,{children:"Solve with NLP solvers (IPOPT, SNOPT)"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Differential Dynamic Programming (DDP)"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Second-order method"}),"\n",(0,r.jsx)(e.li,{children:"Iteratively improves trajectory"}),"\n",(0,r.jsx)(e.li,{children:"Good for dynamic systems"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"CHOMP and STOMP"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Covariant Hamiltonian Optimization"}),"\n",(0,r.jsx)(e.li,{children:"Stochastic Trajectory Optimization"}),"\n",(0,r.jsx)(e.li,{children:"Handle complex cost functions"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"humanoid-balance-control",children:"Humanoid Balance Control"}),"\n",(0,r.jsx)(e.h3,{id:"the-balance-problem",children:"The Balance Problem"}),"\n",(0,r.jsx)(e.p,{children:"Humanoids must actively maintain balance:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Static Balance"}),": CoM over support polygon"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Dynamic Balance"}),": Zero Moment Point (ZMP) in support"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Push Recovery"}),": Responding to disturbances"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"zero-moment-point-zmp",children:"Zero Moment Point (ZMP)"}),"\n",(0,r.jsx)(e.p,{children:"The ZMP is where the total moment of inertia and gravity forces is zero:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"ZMP condition for stability:\nThe ZMP must remain within the support polygon\n\nSupport Polygon:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                         \u2502\n\u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502\n\u2502    \u2502  Left Foot  \u2502      \u2502\n\u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502\n\u2502           ZMP \u2022         \u2502\n\u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502\n\u2502    \u2502  Right Foot \u2502      \u2502\n\u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502\n\u2502                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,r.jsx)(e.h3,{id:"linear-inverted-pendulum-model-lipm",children:"Linear Inverted Pendulum Model (LIPM)"}),"\n",(0,r.jsx)(e.p,{children:"Simplified model for walking:"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Assumptions:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Mass concentrated at Center of Mass (CoM)"}),"\n",(0,r.jsx)(e.li,{children:"CoM moves at constant height"}),"\n",(0,r.jsx)(e.li,{children:"No angular momentum"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Dynamics:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"CoM acceleration = (g/z_c) \xd7 (CoM position - ZMP position)\n\nWhere:\n- g: gravity\n- z_c: CoM height\n- This is an unstable second-order system\n"})}),"\n",(0,r.jsx)(e.h3,{id:"capture-point-dynamics",children:"Capture Point Dynamics"}),"\n",(0,r.jsxs)(e.p,{children:["The ",(0,r.jsx)(e.strong,{children:"Capture Point (CP)"})," is where the robot must step to stop:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"CP = CoM + CoM_velocity / \u03c9\n\nWhere \u03c9 = \u221a(g/z_c)\n\nIf the robot places its foot at the CP, it can come to rest.\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Divergent Component of Motion (DCM)"}),":\nModern extension of capture point theory for more complex scenarios."]}),"\n",(0,r.jsx)(e.h2,{id:"walking-pattern-generation",children:"Walking Pattern Generation"}),"\n",(0,r.jsx)(e.h3,{id:"footstep-planning",children:"Footstep Planning"}),"\n",(0,r.jsx)(e.p,{children:"Determining where to place feet:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502           Footstep Planning                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                  \u2502\n\u2502  Input: Start pose, goal pose, obstacles        \u2502\n\u2502                                                  \u2502\n\u2502  Output: Sequence of footstep locations         \u2502\n\u2502                                                  \u2502\n\u2502     \u250c\u2500\u2500\u2510                                        \u2502\n\u2502     \u2502L1\u2502                                        \u2502\n\u2502     \u2514\u2500\u2500\u2518  \u250c\u2500\u2500\u2510                                  \u2502\n\u2502           \u2502R1\u2502                                  \u2502\n\u2502     \u250c\u2500\u2500\u2510  \u2514\u2500\u2500\u2518                                  \u2502\n\u2502     \u2502L2\u2502       \u250c\u2500\u2500\u2510                             \u2502\n\u2502     \u2514\u2500\u2500\u2518       \u2502R2\u2502                             \u2502\n\u2502           \u250c\u2500\u2500\u2510 \u2514\u2500\u2500\u2518                             \u2502\n\u2502           \u2502L3\u2502                                  \u2502\n\u2502           \u2514\u2500\u2500\u2518  \u250c\u2500\u2500\u2510                            \u2502\n\u2502                 \u2502R3\u2502 Goal                       \u2502\n\u2502                 \u2514\u2500\u2500\u2518                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,r.jsx)(e.h3,{id:"center-of-mass-trajectory",children:"Center of Mass Trajectory"}),"\n",(0,r.jsx)(e.p,{children:"Once footsteps are planned, generate CoM trajectory:"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Preview Control"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Use future footstep locations"}),"\n",(0,r.jsx)(e.li,{children:"Plan CoM trajectory to keep ZMP stable"}),"\n",(0,r.jsx)(e.li,{children:"MPC-based approaches common"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"CoM Trajectory Requirements:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"ZMP stays in support polygon"}),"\n",(0,r.jsx)(e.li,{children:"Smooth transitions between support phases"}),"\n",(0,r.jsx)(e.li,{children:"Respect velocity/acceleration limits"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"swing-leg-trajectory",children:"Swing Leg Trajectory"}),"\n",(0,r.jsx)(e.p,{children:"Moving the non-support leg:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Ground clearance"}),": Avoid obstacles"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Smooth motion"}),": Minimize vibrations"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Landing preparation"}),": Appropriate velocity at contact"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"Typically polynomial (cubic, quintic) or spline trajectories."}),"\n",(0,r.jsx)(e.h2,{id:"whole-body-control",children:"Whole-Body Control"}),"\n",(0,r.jsx)(e.h3,{id:"task-space-control",children:"Task-Space Control"}),"\n",(0,r.jsx)(e.p,{children:"Control in Cartesian space rather than joint space:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"Task: Control end-effector position x \u2208 \u211d\xb3\nJoint configuration: q \u2208 \u211d\u207f\n\nForward kinematics: x = f(q)\nJacobian: J = \u2202f/\u2202q\n\nVelocity mapping: \u1e8b = J(q)q\u0307\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Resolved Rate Control:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"q\u0307 = J\u207a\u1e8b_desired\n\nWhere J\u207a is the pseudoinverse of J\n"})}),"\n",(0,r.jsx)(e.h3,{id:"hierarchical-task-control",children:"Hierarchical Task Control"}),"\n",(0,r.jsx)(e.p,{children:"Managing multiple tasks with priorities:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"Priority Stack:\n1. Safety constraints (highest)\n2. Balance maintenance\n3. End-effector task\n4. Posture optimization (lowest)\n\nLower priority tasks operate in null space of higher priorities.\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Null Space Projection:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"def hierarchical_control(tasks, jacobians, q):\n    q_dot = np.zeros(n_joints)\n    N = np.eye(n_joints)  # Null space projector\n\n    for task, J in zip(tasks, jacobians):\n        # Project task into available null space\n        J_proj = J @ N\n\n        # Compute task contribution\n        q_dot += np.linalg.pinv(J_proj) @ (task - J @ q_dot)\n\n        # Update null space for next level\n        N = N - np.linalg.pinv(J_proj) @ J_proj\n\n    return q_dot\n"})}),"\n",(0,r.jsx)(e.h3,{id:"optimization-based-control",children:"Optimization-Based Control"}),"\n",(0,r.jsx)(e.p,{children:"Modern whole-body control uses QP optimization:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"minimize    ||J_task q\u0307 - \u1e8b_desired||\xb2 + regularization terms\n  q\u0307, \u03c4\n\nsubject to  Dynamics: M(q)q\u0308 + h(q,q\u0307) = S\u03c4 + J\u1d9c\u1d40f_c\n            Joint limits: q_min \u2264 q \u2264 q_max\n            Torque limits: \u03c4_min \u2264 \u03c4 \u2264 \u03c4_max\n            Contact constraints\n            Friction cone constraints\n"})}),"\n",(0,r.jsx)(e.h2,{id:"impedance-and-compliance-control",children:"Impedance and Compliance Control"}),"\n",(0,r.jsx)(e.h3,{id:"impedance-control",children:"Impedance Control"}),"\n",(0,r.jsx)(e.p,{children:"Make robot behave like a spring-damper system:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"Desired behavior:\nF = K(x_d - x) + D(\u1e8b_d - \u1e8b)\n\nWhere:\n- K: Stiffness matrix\n- D: Damping matrix\n- x_d: Desired position\n- x: Actual position\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Benefits:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Safe interaction with environment"}),"\n",(0,r.jsx)(e.li,{children:"Robust to position errors"}),"\n",(0,r.jsx)(e.li,{children:"Natural compliance for contact tasks"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"variable-impedance",children:"Variable Impedance"}),"\n",(0,r.jsx)(e.p,{children:"Adjusting stiffness based on task:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"High stiffness"}),": Precise positioning"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Low stiffness"}),": Safe contact, compliant motion"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Adaptive"}),": Learn appropriate impedance"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"model-predictive-control-mpc",children:"Model Predictive Control (MPC)"}),"\n",(0,r.jsx)(e.h3,{id:"mpc-framework",children:"MPC Framework"}),"\n",(0,r.jsx)(e.p,{children:"Optimize over a rolling horizon:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"At each time step:\n1. Measure current state x(t)\n2. Solve optimization over horizon [t, t+T]:\n   minimize \u03a3 L(x_k, u_k) + V(x_N)\n   subject to dynamics, constraints\n3. Apply first control u(t)\n4. Repeat at next time step\n"})}),"\n",(0,r.jsx)(e.h3,{id:"mpc-for-locomotion",children:"MPC for Locomotion"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Centroidal MPC:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Control center of mass and angular momentum"}),"\n",(0,r.jsx)(e.li,{children:"Optimize contact forces"}),"\n",(0,r.jsx)(e.li,{children:"Runs at ~100-500 Hz"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Full-Body MPC:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Control all joints"}),"\n",(0,r.jsx)(e.li,{children:"More accurate but computationally expensive"}),"\n",(0,r.jsx)(e.li,{children:"Emerging with faster solvers"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"safety-and-constraint-handling",children:"Safety and Constraint Handling"}),"\n",(0,r.jsx)(e.h3,{id:"collision-avoidance",children:"Collision Avoidance"}),"\n",(0,r.jsx)(e.p,{children:"Real-time collision checking:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"def check_collision(robot_state, obstacles):\n    # Get robot geometry at current state\n    robot_geometry = robot.get_collision_geometry(robot_state)\n\n    # Check against all obstacles\n    for obstacle in obstacles:\n        if gjk_collision_check(robot_geometry, obstacle):\n            return True  # Collision detected\n\n    return False  # No collision\n"})}),"\n",(0,r.jsx)(e.h3,{id:"safety-constraints-in-control",children:"Safety Constraints in Control"}),"\n",(0,r.jsx)(e.p,{children:"Embedding safety in the control loop:"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Control Barrier Functions (CBFs):"}),"\nEnsure safety set is forward invariant"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Velocity/Force Limiting:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"def safe_command(desired_cmd, limits):\n    # Clip to joint velocity limits\n    safe_vel = np.clip(desired_cmd.velocity,\n                       limits.vel_min, limits.vel_max)\n\n    # Clip to joint torque limits\n    safe_torque = np.clip(desired_cmd.torque,\n                          limits.torque_min, limits.torque_max)\n\n    return SafeCommand(safe_vel, safe_torque)\n"})}),"\n",(0,r.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(e.p,{children:"Motion planning and control enable humanoid robots to move effectively:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Path Planning"}),": Finding collision-free paths (RRT, PRM, A*)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Trajectory Optimization"}),": Smooth, optimal motion"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Balance Control"}),": Maintaining stability (ZMP, Capture Point)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Walking Generation"}),": Footsteps and CoM trajectories"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Whole-Body Control"}),": Coordinating all degrees of freedom"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Safety"}),": Ensuring safe operation at all times"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"Modern approaches increasingly use:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Optimization-based methods"}),"\n",(0,r.jsx)(e.li,{children:"Model Predictive Control"}),"\n",(0,r.jsx)(e.li,{children:"Learning-based components"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"review-questions",children:"Review Questions"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"Explain the difference between C-space and workspace."}),"\n",(0,r.jsx)(e.li,{children:"Compare RRT and PRM planning algorithms."}),"\n",(0,r.jsx)(e.li,{children:"What is the Zero Moment Point and why is it important?"}),"\n",(0,r.jsx)(e.li,{children:"Describe the hierarchical task control approach."}),"\n",(0,r.jsx)(e.li,{children:"How does Model Predictive Control work for locomotion?"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"hands-on-exercise",children:"Hands-On Exercise"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Exercise 5.1: Motion Planning Implementation"})}),"\n",(0,r.jsx)(e.p,{children:"Implement a simple motion planner:"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"Create a 2D environment with obstacles"}),"\n",(0,r.jsx)(e.li,{children:"Implement RRT algorithm"}),"\n",(0,r.jsx)(e.li,{children:"Implement RRT* for path optimization"}),"\n",(0,r.jsx)(e.li,{children:"Visualize the exploration tree and final path"}),"\n",(0,r.jsx)(e.li,{children:"Compare path quality and computation time"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"Extensions:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Add dynamics constraints"}),"\n",(0,r.jsx)(e.li,{children:"Implement trajectory smoothing"}),"\n",(0,r.jsx)(e.li,{children:"Add real-time replanning capability"}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>s,x:()=>l});var o=i(6540);const r={},t=o.createContext(r);function s(n){const e=o.useContext(t);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:s(n.components),o.createElement(t.Provider,{value:e},n.children)}}}]);